import math
import threading
import time
import sys

# Global count of the number of primes found
total_primes = 0

# Global count of the numbers examined
total_numbers_checked = 0

# The number of threads to use (should try 1, 10, 50, and 101)
thread_count = 10

# Lock for synchronizing access to shared resources
lock = threading.Lock()

def check_prime(n: int) -> bool:
    """
    Check if a number is prime using a common optimization method.

    Parameters
    ----------
    n : int
        Number to determine if prime.

    Returns
    -------
    bool
        True if n is prime, otherwise False.
    """
    if n <= 3:
        return n > 1
    if n % 2 == 0 or n % 3 == 0:
        return False
    # Use a loop to check divisibility
    for i in range(5, int(n**0.5) + 1, 6):
        if n % i == 0 or n % (i + 2) == 0:
            return False
    return True

def compute_primes_in_range(start: int, end: int) -> None:
    """
    Count the number of primes in the given range and update global counters.

    Parameters
    ----------
    start : int
        Starting number of the range (inclusive).
    end : int
        Ending number of the range (exclusive).
    """
    global total_primes, total_numbers_checked

    local_prime_count = 0
    local_numbers_examined = 0

    for number in range(start, end):
        if check_prime(number):
            local_prime_count += 1
        local_numbers_examined += 1

    with lock:
        total_primes += local_prime_count
        total_numbers_checked += local_numbers_examined

def validate_inputs(first_number: int, interval: int, thread_count: int) -> None:
    """
    Validate the input parameters.

    Parameters
    ----------
    first_number : int
        Starting number for the range.
    interval : int
        Total count of numbers to examine.
    thread_count : int
        Number of threads to use.

    Raises
    ------
    ValueError
        If any input parameters are invalid.
    """
    if not isinstance(first_number, int) or first_number < 0:
        raise ValueError("First number must be a non-negative integer.")
    
    if not isinstance(interval, int) or interval <= 0:
        raise ValueError("Interval must be a positive integer.")
    
    if not isinstance(thread_count, int) or thread_count <= 0 or thread_count > 101:
        raise ValueError("Thread count must be a positive integer up to 101.")

def main():
    begin_time = time.perf_counter()

    # Set initial parameters
    first_number = 100_000_000
    interval = 370_803
    last_number = first_number + interval

    try:
        # Validate input parameters
        validate_inputs(first_number, interval, thread_count)

        # Calculate the size of each chunk that each thread will handle
        chunk_size = interval // thread_count

        # Create and start threads
        threads = []
        for i in range(thread_count):
            start = first_number + i * chunk_size
            # Ensure the last thread goes all the way to last_number
            end = last_number if i == thread_count - 1 else start + chunk_size

            t = threading.Thread(target=compute_primes_in_range, args=(start, end))
            threads.append(t)
            t.start()

        # Wait for all threads to complete
        for t in threads:
            t.join()

        # Final assertions to validate the results
        assert total_numbers_checked == 370_803, f"Should check exactly 370,803 numbers, but checked {total_numbers_checked:,}"
        assert total_primes == 20_144, f"Should find exactly 20,144 primes but found {total_primes:,}"

        # Print out summary
        print(f'Numbers processed = {total_numbers_checked:,}')
        print(f'Primes found = {total_primes:,}')
        total_time = "{:.2f}".format(time.perf_counter() - begin_time)
        print(f'Total time = {total_time} sec')

    except ValueError as e:
        print(f"Input Error: {e}")
        sys.exit(1)  # Exit the program with an error code

if __name__ == '__main__':
    main()
